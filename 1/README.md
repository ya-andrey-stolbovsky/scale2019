# Пример использования Yandex Message Queue и Cloud Functions

## Введение
У нас есть простой бот для Slack. Его задача — получать события от Github про репозиторий в Github и посылать уведомления об этих событиях в Slack-канал. Бот уже создан и развёрнут как [функция Yandex Cloud Functions](https://console.cloud.yandex.ru/folders/b1ghrc520j5o6cv0gneg/functions/function/d4enfpka0bcss2cubo5s).

Сейчас архитектура бота очень простая — при получении события от Github бот сразу же отправляет его в Slack. У этой архитектуры есть недостаток: при возникновении любой проблемы с отправкой в Slack событие от Github теряется. Github не перепосылает неуспешные события.

Для иллюстрации возможных проблем в код бота добавлен механизм failure injection, который имитирует сбой 50% запросов к Slack.

Проверим, как это работает:
1. Откройте в новой вкладке [канал в Slack](https://app.slack.com/client/TNJMG6S4T/CNY224V39).
1. Откройте в новой вкладке [задачу в Github](https://github.com/Scale2019TestAccount1/hello-world/issues/1).
2. Добавьте несколько комментариев.

Из-за сбоев при отправке в Slack не все комментарии поступают в канал.

## Задача
Необходимо сделать бот более надёжным. Для этого воспользуемся ещё одной технологией Яндекс.Облака - очередью сообщений Yandex Message Queue.

Сделаем так, чтобы события от Github бот сохранял в надёжную очередь, а затем отдельным шагом бот будет отправлять сообщение из очереди в Slack. Если этапе отправки в Slack произойдёт ошибка, то уведомление останется в очереди до тех пор, пока оно не будет успешно обработано.

Давайте повысим надёжность бота при помощи очереди сообщений. Для этого необходимо создать очередь, создать триггер на вызов функции и переключить бота на использование очереди. Для простоты демонстрации код, работающий с очередью, уже есть в коде бота, его просто нужно включить.

## Создание очереди YMQ
1. Откройте [рабочий каталог](https://console.cloud.yandex.ru/folders/b1ghrc520j5o6cv0gneg) Яндекс.Облака.
1. Кликните на кнопку "создать ресурс" и выберите пункт "очередь сообщений". Появится окно создания очереди.
1. Поставьте стандартный таймаут видимости — 2 секунды.
2. Придумайте имя для новой очереди и нажмите на кнопку "создать очередь".

Очередь создана.

## Настройка триггера
1. Откройте [триггеры](https://console.cloud.yandex.ru/folders/b1ghrc520j5o6cv0gneg/functions/triggers) Cloud Functions.
3. Нажмите на кнопку "Создать триггер".
4. Придумайте имя триггера (маленькие буквы, 3+ символов).
5. Остальные поля (очередь, аккаунт, функция) подставятся автоматически.
6. Нажмите на кнопку "Сохранить".

Триггер создан.

## Переключение на использование очереди в боте
1. Откройте [функцию бота](https://console.cloud.yandex.ru/folders/b1ghrc520j5o6cv0gneg/functions/function/d4enfpka0bcss2cubo5s).
6. В меню слева откройте пункт "Редактор".
7. Выберите файл `main.py`, содержащий код функции.
7. Найдите в нём функцию `http_handler`. Закомментируйте в ней строку с вызовом `send_to_slack`.
7. Раскомментируй строку с переменной queue_url и подставьте туда URL очереди, созданной ранее.
7. Раскомментируйте строку с вызовом `send_to_ymq_queue`.
8. Функция http_handler должна выглядеть примерно так:
```python
def http_handler(event, context):
    # --- Comment this ---
    # send_to_slack(message=json.loads(event['body']))

    # --- Uncomment this ---
    queue_url = YOUR_QUEUE_URL
    send_to_ymq_queue(queue_url, event['body'])

    return make_response()
```
7. Нажмите на кнопку "Создать версию".

Бот переведён на использование очереди.

## Проверка результата
Проверим, что надёжность повысилась:
1. Откройте в новой вкладке [канал в Slack](https://app.slack.com/client/TNJMG6S4T/CNY224V39).
1. Откройте в новой вкладке [задачу в Github](https://github.com/Scale2019TestAccount1/hello-world/issues/1).
2. Добавьте несколько комментариев.

Через некоторое время все добавленные комментарии появятся в канале Slack. Из-за имитации сбоев при отправке в Slack они могут задерживаться или немного менять порядок — но все обязательно будут доставлены.

## Заключение

Использование очередей сообщений повышает надёжность системы, а интеграция с Cloud Functions позволяет просто использовать очереди Message Queue в функциях.
